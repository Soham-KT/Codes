import multiprocessing as mp
from math import *
import time
import wmi
import matplotlib.pyplot as plt
import numpy as np

plt.style.use("ggplot")


class integration:
    i = 1

    def __init__(self, function, accuracy, l_limit, u_limit):
        self.func = function
        self.acc = accuracy
        self.a = l_limit
        self.b = u_limit

        self.h = (self.b - self.a) / (self.acc * 6)
        self.tables_x = []
        self.tables_y = []

    def y_vals(self, arg):
        x = self.a + arg / (self.acc * 6.0)
        return eval(self.func)

    @staticmethod
    def add(arg):
        if integration.i % 2 == 0 and integration.i % 3 != 0:
            integration.i += 1
            return arg

        if integration.i % 2 != 0 and integration.i % 3 != 0:
            integration.i += 1
            return 5 * arg

        elif integration.i % 6 == 0:
            integration.i += 1
            return 2 * arg

        elif integration.i % 3 == 0 and integration.i % 2 != 0:
            integration.i += 1
            return 6 * arg


if __name__ == "__main__":
    fun = input("Enter function with variable as x: ")
    a = float(input("Enter lower limit: "))
    b = float(input("Enter upper limit: "))

    acc_lst = []
    acc = 1
    acc_lst.append(acc)
    no_of_pross = 5
    time_taken = []
    heat_generated = []
    while acc <= 100000:
        inte = integration(fun, acc, a, b)
        lst = [i for i in range(inte.acc * 6 + 1)]

        start = time.time()
        pool = mp.Pool(processes=no_of_pross)
        inte.tables_y = pool.map(inte.y_vals, lst)
        first_ele = inte.tables_y[0]
        last_ele = inte.tables_y[-1]
        inte.tables_y.pop(0)
        inte.tables_y.pop(-1)
        final_lst = pool.map(inte.add, inte.tables_y)
        Integration = 0.3 * inte.h * (first_ele + last_ele + sum(final_lst))

        pool.close()
        pool.join()
        end = time.time()

        time_taken.append(end - start)

        w = wmi.WMI(namespace="root\\OpenHardwareMonitor")
        temperature_info = w.Sensor()
        for sensor in temperature_info:
            if sensor.SensorType == u'Temperature':
                heat_generated.append(sensor.Value)

        acc *= 10
        acc_lst.append(acc)

    acc_lst.pop(-1)
    for i in range(len(time_taken)):
        time_taken[i] = round(time_taken[i], 5)

    t_indices = np.arange(len(acc_lst))

    plt.bar(t_indices, heat_generated, width=0.25)
    plt.xticks(ticks=t_indices, labels=acc_lst)
    plt.xlabel("Number of divisions")
    plt.ylabel("Heat Generated by CPU (in Celsius)")
    for (xi, yi, tt) in zip(t_indices, heat_generated, time_taken):
        plt.text(xi, yi, str(tt)+"s", ha="center")
    plt.show()
